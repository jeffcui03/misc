#This is the start of ~hal@example.com/hal/q/env shell script

export HALQ=${HALQ:=~hal@example.com}
export QHOME=${HALQ}/q/version/4.0
export QINIT=${HALQ}/q/sys/q.q
export Q=${HALQ}/q/Q

f=${HALQ}/q/lic/$(hostname)
if   [ -e ${f}:2  ]; then k=2;
elif [ -e ${f}:4  ]; then k=4;
elif [ -e ${f}:6  ]; then k=6;
elif [ -e ${f}:8  ]; then k=8;
elif [ -e ${f}:12 ]; then k=12;
else echo "Unable to find license dir: ${f}:[n]";
fi
export QLIC=${f}:$k QCORES=$k


qcores(){
 [ $# -eq 0 ] && k=$QCORES || k=$1  # optional 1st arg: count of licensed cores, else set to env variable QCORES
 a=($(/bin/lscpu | /bin/grep 'NUMA node[0-9]'|/bin/awk '{print $NF}')) #array of NUMA nodes
 m=${a[(($RANDOM%${#a[@]}))]}                                          #pick random NUMA node
 c=($(echo $m | /bin/awk -F '[-,]' '{print $1,$2}'))                   #array of start & end core
 n=$((1+${c[1]}-${c[0]}))                                              #number of cores on node
 if [ $n -gt $k ]; then                                                #if more cores per node than licensed
  i=$(( $RANDOM % (($n-$k+1)) ))                                       # random offset for 1st cpu
  echo "$((${c[0]}+$i))-$((${c[0]}+$i+$k-1))"                          # cpu range: start-end
 else                                                                  # if licensed cores >= cores per node
  echo "${c[0]}-${c[1]}"                                               # use full range of NUMA node
 fi
}


ulimit -n $(ulimit -n -H)  # set max open file limit
unalias q &> /dev/null
qbind() { echo /usr/bin/numactl --all --interleave=all --physcpubind=$(qcores) ${QHOME}/l64/q; }
if [ -f /usr/bin/rlwrap ]; then
 q() { /usr/bin/rlwrap $(qbind) "${@}"; }
else
 q() { $(qbind) "${@}"; }
fi
declare -fx qcores qbind q

#end of example q/env script


===============================================================================================================
Convert symbol from an enum array to symbol array
==============================================================================================================
dt:2019.08.01
symbolsTraded:exec symbol from select distinct symbol from order where date=dt
ev:"i"$symbolsTraded
symbolsTradedList:rsym ev    
show count symbolsTradedList



===========================================================================
Error List
https://code.kx.com/q/basics/errors/
=========================================================================

=============================================================================================================

#This is to 
Code to generate orderbook every 10 seconds 3 min before the Execution to 3 min after the Execution

========================================================================================================


%%q

\l report/orderbook/orderbook.q

\c 150 300

tradeTm:2019.01.14+14:48:29.851000t
startTm: tradeTm - 00:03
endTm:tradeTm + 00:03
snapshotTm:startTm

#Since "til" can only be used on integers
# use 0D00:00:10*til <int>
snapshotTmList:startTm+0D00:00:10*til 1+"j"$`second$div[endTm-startTm;00:00:10]
snapshotList:()
Ticker:`CTL
#Use snapshotTimList to generate OrderBook list
snapshotList:{[snapshotTm]
  0N!("snapshotTm = ", string(snapshotTm));
  .api.orderbook[`symbol`time`top`class!(Ticker;snapshotTm;5;`equities)]
 }each snapshotTmList


#In a typical 5Level 'B' + 5Level "S", one time in snapshotTmList correponds to 10 lines
# I want a table with time column repeat 10 times for one orderbook snapshot(5 "B" + 5 "S)
# %%q
# 10 # `A
#  `A`A`A`A`A`A`A`A`A`A
# 10 # 1
#  1 1 1 1 1 1 1 1 1 1


# 10#/:snapshotTmList => 10 * every element in snapshotTimeList
tradeTbl: 0!([]time:raze 10#/:snapshotTmList)!raze snapshotList

#venue is symbol list, venueqty is integer list
#we have to modify them to string so that save to disk does not report `type error
tradeTbl:update raze each string venue," "sv/:string each venueqty from tradeTbl
`:/home/cuix/tradeTbl2.csv 0: csv 0: tradeTbl


#wj example
t1:wj1[w;`ordertime;t0;(t0;({count distinct ?[x=`SS;`S;x]};`side))]
t1 is generated by joining t0 with t0
on a window("w") of 2 lists

The only surprising thing is on https://code.kx.com/v2/ref/wj/, f0, f1 are aggregation functions applied to values in q columns c0,c1 over the intervals

{count distinct ?[x=`SS;`S;x]}
is an aggregation function

#wj example
n:1000
t0:update `p#symbol from select from order where date=d
w:(neg n;n)+\:t`ordertime
t1:wj1[w;`symbol`ordertime;t;(t;({count distinct x};`side))]
t1:xcol[enlist[`side]!enlist `windowdistinct;t1]
t1[`side]:t0`side
select from t1 where windowdistinct>1



q)d:`:/opt/q  /leading colon tells q the symbol is a file handle
q)key d       /key in this case is like “ls” without overhead of system call
`#q.q.BKP.2016-12-01#`LICENSE.ffi`README-3.4.txt`README-3.5.txt`README.ffi`RE..

q)0N 1#(` sv d,)'[key d]
:/opt/q/#q.q.BKP.2016-12-01#
:/opt/q/LICENSE.ffi
:/opt/q/README-3.4.txt
:/opt/q/README-3.5.txt
..

So maybe a simple utility function can take a list of dates and return a dictionary of tables found by date, etc.
In the past, I’ve created some minimal set of utilities in a ${QHOME}/q.q file that gets loaded automatically with each q session so that basic functions don’t have to be rewritten in each script.
e.g. reserve the “.sys” namespace for utilities like writing log messages

q)\d .sys
q.sys)msg:{v:("dv"$'.z.P),$[10h=type x,:();enlist x;x]; -2@" "sv@[v;where not 10h=type'[v];string];}
q.sys)\d .

then the user scripts get simpler and all the logging goes to stderr, standard date/time display, does some basic number to string converting, etc.

q).sys.msg"start of job"
2023.07.14 11:49:44 start of job

q).sys.msg("mean";0.5;"std dev:";4.55)
2023.07.14 12:02:20 mean 0.5 std dev: 4.55

.  As long as things take more than 100 milliseconds, there’s room for study and improvement.
Also relative timings are useful to get a feel for speed overall and kdb’s particular optimal paths.

The system command: \ts or \ts:n is very useful for quick timings and improving intuition.
https://code.kx.com/q/basics/syscmds/#ts-time-and-space


bitscan.org
etherscan.org
chainanalysis.com 
trmlabs.com
